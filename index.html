<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>í•€ë³¼ ëœë¤ ë½‘ê¸°</title>

    <!-- OG -->
    <meta property="og:title" content="í•€ë³¼ ëœë¤ ë½‘ê¸°" />
    <meta
      property="og:description"
      content="í•€ë³¼ ê¸°ê³„ë¡œ ë¬´ì‘ìœ„ ìš°ìŠ¹ìë¥¼ ë½‘ì•„ë³´ì„¸ìš”! ğŸ±"
    />
    <meta
      property="og:image"
      content="https://dummyimage.com/1200x630/1e293b/ffffff&text=Random"
    />
    <meta property="og:image:width" content="1200" />
    <meta property="og:image:height" content="630" />

    <link
      rel="icon"
      type="image/svg+xml"
      href="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20100%20100'%3E%3Ctext%20x='50'%20y='72'%20text-anchor='middle'%20font-size='80'%3E%F0%9F%8E%B1%3C/text%3E%3C/svg%3E"
    />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png" />
    <link rel="apple-touch-icon" href="/favicon.png" />

    <script src="https://cdn.tailwindcss.com"></script>
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1204894220949193"
     crossorigin="anonymous"></script>
    <!-- responsive-base -->
    <style>
      /* responsive-base */
      *, *::before, *::after {
        box-sizing: border-box;
      }
      html {
        -webkit-text-size-adjust: 100%;
      }
      img,
      video,
      canvas,
      svg {
        max-width: 100%;
        height: auto;
      }
      table {
        width: 100%;
      }
      pre,
      code {
        white-space: pre-wrap;
        word-break: break-word;
      }
    </style>
  <style>
    .adsense-block {
      margin: 16px 0;
      display: flex;
      justify-content: center;
    }
    .adsbygoogle {
      display: block;
      margin: 16px auto;
        text-align: center;
}
  </style>
  <style>
    .lang-switch {
      position: fixed;
      top: 16px;
      right: 16px;
      display: inline-flex;
      gap: 0;
      padding: 3px;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
      z-index: 100;
      border: 1px solid rgba(34, 211, 238, 0.3);
    }
    .lang-switch button {
      border: none;
      background: transparent;
      color: rgba(255, 255, 255, 0.7);
      font-size: 12px;
      font-weight: 700;
      padding: 7px 14px;
      border-radius: 999px;
      cursor: pointer;
      transition: all 0.2s ease;
      min-width: 44px;
      text-align: center;
      letter-spacing: 0.02em;
    }
    .lang-switch button.active {
      background: linear-gradient(135deg, #06b6d4, #8b5cf6);
      color: #fff;
      box-shadow: 0 2px 8px rgba(34, 211, 238, 0.5);
    }
    .lang-switch button:not(.active):hover {
      background: rgba(34, 211, 238, 0.2);
      color: rgba(255, 255, 255, 0.9);
    }
  </style>
</head>

  <body
    class="bg-black text-white min-h-screen flex flex-col items-center py-6 overflow-y-auto"
    style="
      background: linear-gradient(
        180deg,
        #0a0a0f 0%,
        #1a0a2e 50%,
        #0a0a0f 100%
      );
    "
  >
  <div class="lang-switch" role="tablist" aria-label="Language switcher">
    <button type="button" data-lang="ko" class="active">KR</button>
    <button type="button" data-lang="en">EN</button>
  </div>
  <div class="w-full max-w-4xl flex flex-col items-center gap-5">
      <div
        class="flex flex-col md:flex-row md:items-center md:justify-between w-full gap-3"
      >
        <div>
          <h1
            class="text-4xl font-extrabold mb-8 bg-gradient-to-r from-pink-500 via-cyan-500 to-purple-500 bg-clip-text text-transparent drop-shadow-[0_0_15px_rgba(236,72,153,0.5)]"
            data-i18n="title"
          >
            ğŸ± ë„¤ì˜¨ í•€ë³¼ ëœë¤ ë½‘ê¸°
          </h1>
        </div>
        <a
          href="https://funnyfunny.cloud/"
          target="_blank"
          rel="noreferrer"
          class="self-start md:self-center inline-flex items-center gap-2 px-4 py-2 rounded-xl text-sm font-bold border border-cyan-400/60 bg-white/5 hover:bg-white/10 transition shadow-[0_0_15px_rgba(34,211,238,0.3)]"
        >
          <span data-i18n="moreServices">âœ¨ ë‹¤ë¥¸ ì„œë¹„ìŠ¤ ë³´ê¸°</span>
        </a>
      </div>

      <!-- ì…ë ¥ ì˜ì—­ -->
      <div
        class="w-full max-w-md p-5 rounded-xl mb-4 border-2 border-cyan-500/30 shadow-[0_0_30px_rgba(34,211,238,0.3)]"
        style="
          background: linear-gradient(
            135deg,
            rgba(6, 182, 212, 0.1) 0%,
            rgba(168, 85, 247, 0.1) 100%
          );
        "
      >
        <label class="block mb-2 text-sm text-cyan-300 font-bold" data-i18n="labelParticipants">
          ì°¸ê°€ì ì´ë¦„ ì…ë ¥ (ê³µë°±ìœ¼ë¡œ êµ¬ë¶„)
        </label>
        <textarea
          id="participantsInput"
          data-i18n-placeholder="placeholderParticipants"
          placeholder="ì˜ˆ: ì² ìˆ˜ ì˜í¬ ë¯¼ìˆ˜&#10;ë˜ëŠ” ê°œìˆ˜ ì§€ì •: ì² ìˆ˜2 ì˜í¬*3 ë¯¼ìˆ˜/5"
          class="w-full h-24 p-3 rounded text-sm mb-3 resize-none bg-black/50 border border-cyan-500/50 text-cyan-100 placeholder-cyan-500/50 focus:border-cyan-400 focus:shadow-[0_0_15px_rgba(34,211,238,0.5)] focus:outline-none"
        >
ì°¸ê°€ì1 ì°¸ê°€ì2 ì°¸ê°€ì3</textarea
        >
        <p class="text-xs text-pink-300 mb-4" data-i18n="hintCount">
          ğŸ’¡ ì´ë¦„ ë’¤ì— ìˆ«ì(ì² ìˆ˜2) ë˜ëŠ” ë³„í‘œ(ì˜í¬*3)ë¡œ ê³µ ê°œìˆ˜ ì§€ì • ê°€ëŠ¥
        </p>
        <button
          id="startBtn"
          class="w-full py-3 rounded-xl font-bold transition-all duration-300 transform hover:scale-105 shadow-[0_0_20px_rgba(34,211,238,0.5)]"
          style="background: linear-gradient(135deg, #06b6d4 0%, #8b5cf6 100%)"
          data-i18n="startBtn"
        >
          ê²Œì„ ì‹œì‘ ğŸš€
        </button>
      </div>
    </div>

    <!-- Canvas Container -->
    <div
      id="canvasContainer"
      class="hidden relative w-full max-w-lg overflow-hidden rounded-xl border-2 border-cyan-500/50 shadow-[0_0_50px_rgba(34,211,238,0.4)]"
      style="height: 80vh"
    >
      <canvas
        id="pinballCanvas"
        width="500"
        height="2000"
        class="block"
        style="
          background: linear-gradient(
            180deg,
            #0a0a0f 0%,
            #1a0a2e 30%,
            #0a0a0f 60%,
            #1a0a2e 100%
          );
        "
      ></canvas>
    </div>

    <!-- ê²°ê³¼ -->
    <div
      id="result"
      class="hidden mt-6 bg-slate-800 p-5 rounded-xl w-full max-w-md max-h-[80vh] overflow-y-auto"
    ></div>

    <script>
      // =========================
      // i18n
      // =========================
      const translations = {
        ko: {
          metaTitle: "í•€ë³¼ ëœë¤ ë½‘ê¸°",
          metaDescription: "í•€ë³¼ ê¸°ê³„ë¡œ ë¬´ì‘ìœ„ ìš°ìŠ¹ìë¥¼ ë½‘ì•„ë³´ì„¸ìš”! ğŸ±",
          title: "ğŸ± ë„¤ì˜¨ í•€ë³¼ ëœë¤ ë½‘ê¸°",
          moreServices: "âœ¨ ë‹¤ë¥¸ ì„œë¹„ìŠ¤ ë³´ê¸°",
          labelParticipants: "ì°¸ê°€ì ì´ë¦„ ì…ë ¥ (ê³µë°±ìœ¼ë¡œ êµ¬ë¶„)",
          placeholderParticipants: "ì˜ˆ: ì² ìˆ˜ ì˜í¬ ë¯¼ìˆ˜\në˜ëŠ” ê°œìˆ˜ ì§€ì •: ì² ìˆ˜2 ì˜í¬*3 ë¯¼ìˆ˜/5",
          hintCount: "ğŸ’¡ ì´ë¦„ ë’¤ì— ìˆ«ì(ì² ìˆ˜2) ë˜ëŠ” ë³„í‘œ(ì˜í¬*3)ë¡œ ê³µ ê°œìˆ˜ ì§€ì • ê°€ëŠ¥",
          startBtn: "ê²Œì„ ì‹œì‘ ğŸš€",
          alertNoInput: "ì°¸ê°€ì ì´ë¦„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”!",
          alertNoParticipants: "ì°¸ê°€ìë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”!",
          resultTitle: "ğŸ ì™„ì£¼ ìˆœìœ„",
          resultFinishOrder: "ë²ˆì§¸ë¡œ ì™„ì£¼",
          retryBtn: "ë‹¤ì‹œ í•˜ê¸° ğŸ”„",
        },
        en: {
          metaTitle: "Pinball Random Draw",
          metaDescription: "Draw a random winner with a pinball machine! ğŸ±",
          title: "ğŸ± Neon Pinball Random Draw",
          moreServices: "âœ¨ View More Services",
          labelParticipants: "Enter participant names (separated by spaces)",
          placeholderParticipants: "Ex: Alice Bob Charlie\nOr specify count: Alice2 Bob*3 Charlie/5",
          hintCount: "ğŸ’¡ You can specify ball count with numbers (Alice2) or asterisks (Bob*3)",
          startBtn: "Start Game ğŸš€",
          alertNoInput: "Please enter participant names!",
          alertNoParticipants: "Please enter participants!",
          resultTitle: "ğŸ Finish Ranking",
          resultFinishOrder: "th to finish",
          retryBtn: "Try Again ğŸ”„",
        },
      };

      const defaultLang = "ko";
      const supportedLangs = ["ko", "en"];
      let currentLang = defaultLang;

      function t(key, vars = {}) {
        const langTable = translations[currentLang] || translations.ko;
        let template = langTable?.[key] ?? translations.ko?.[key] ?? key;
        if (typeof template !== "string") return template;
        Object.keys(vars).forEach((k) => {
          template = template.replace(new RegExp(`\\{${k}\\}`, "g"), vars[k]);
        });
        return template;
      }

      function applyTranslations() {
        document.title = t("metaTitle");
        const descMeta = document.querySelector('meta[property="og:description"]');
        if (descMeta) descMeta.setAttribute("content", t("metaDescription"));
        const ogTitleMeta = document.querySelector('meta[property="og:title"]');
        if (ogTitleMeta) ogTitleMeta.setAttribute("content", t("metaTitle"));
        document.documentElement.lang = currentLang;
        document.querySelectorAll("[data-i18n]").forEach((el) => {
          el.textContent = t(el.dataset.i18n);
        });
        document.querySelectorAll("[data-i18n-html]").forEach((el) => {
          el.innerHTML = t(el.dataset.i18nHtml);
        });
        document.querySelectorAll("[data-i18n-placeholder]").forEach((el) => {
          el.placeholder = t(el.dataset.i18nPlaceholder);
        });
      }

      function detectLang() {
        const params = new URLSearchParams(window.location.search);
        const paramLang = params.get("lang");
        if (supportedLangs.includes(paramLang)) return paramLang;
        const stored = localStorage.getItem("preferredLang");
        if (supportedLangs.includes(stored)) return stored;
        const intlLocale =
          typeof Intl === "object" && typeof Intl.DateTimeFormat === "function"
            ? Intl.DateTimeFormat().resolvedOptions().locale
            : "";
        const sources = [
          ...(navigator.languages || []),
          navigator.language,
          navigator.userLanguage,
          intlLocale,
        ]
          .filter(Boolean)
          .map((locale) => locale.toLowerCase());
        const hasKorean = sources.some((locale) => locale.startsWith("ko"));
        return hasKorean ? "ko" : "en";
      }

      function setLang(lang, options = {}) {
        const nextLang = supportedLangs.includes(lang) ? lang : defaultLang;
        currentLang = nextLang;
        window.currentLang = currentLang;
        document.documentElement.lang = nextLang;
        localStorage.setItem("preferredLang", nextLang);
        document.querySelectorAll(".lang-switch button").forEach((button) => {
          button.classList.toggle("active", button.dataset.lang === nextLang);
        });
        applyTranslations();
        if (options.updateUrl) {
          const url = new URL(window.location.href);
          url.searchParams.set("lang", nextLang);
          window.history.replaceState({}, "", url);
        }
      }

      document.querySelectorAll(".lang-switch button").forEach((button) => {
        button.addEventListener("click", () => {
          setLang(button.dataset.lang, { updateUrl: true });
        });
      });

      setLang(detectLang(), { updateUrl: false });

      // Make t() function and currentLang globally available
      window.t = t;
      window.currentLang = currentLang;
      window.setLang = setLang;

      /* ---------------- ì˜¤ë””ì˜¤ ì»¨í…ìŠ¤íŠ¸ ---------------- */
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

      /* ---------------- íš¨ê³¼ìŒ í•¨ìˆ˜ ---------------- */
      function playSound(type = "bounce") {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc.connect(gain);
        gain.connect(audioCtx.destination);

        if (type === "bounce") {
          osc.frequency.value = 400;
          osc.type = "square";
          gain.gain.value = 0.05;
          osc.start();
          osc.frequency.exponentialRampToValueAtTime(
            200,
            audioCtx.currentTime + 0.1
          );
          gain.gain.exponentialRampToValueAtTime(
            0.001,
            audioCtx.currentTime + 0.1
          );
          osc.stop(audioCtx.currentTime + 0.1);
        }

        if (type === "finish") {
          osc.frequency.value = 300;
          osc.type = "sawtooth";
          gain.gain.value = 0.12;
          osc.start();
          osc.frequency.exponentialRampToValueAtTime(
            80,
            audioCtx.currentTime + 0.4
          );
          gain.gain.exponentialRampToValueAtTime(
            0.001,
            audioCtx.currentTime + 0.4
          );
          osc.stop(audioCtx.currentTime + 0.4);
        }
      }

      /* ---------------- ì§„ë™ í•¨ìˆ˜ ---------------- */
      function vibrate(ms = 20) {
        if (navigator.vibrate) {
          navigator.vibrate(ms);
        }
      }

      /* ---------------- ìƒíƒœ ---------------- */
      let balls = [];
      let pins = [];
      let finishedBalls = [];
      let animationId;
      let participants = [];
      let bird = null; // ì—‘ìŠ¤íŠ¸ë¼ ìƒˆ
      let cameraY = 0;
      let targetCameraY = 0;
      let gameStartTime = 0;
      const MAX_GAME_TIME = 60000; // ìµœëŒ€ 60ì´ˆ
      const MIN_BALL_SPEED = 0.5; // ê³µì˜ ìµœì†Œ ì†ë„
      const canvasContainer = document.getElementById("canvasContainer");

      /* ---------------- DOM ---------------- */
      const canvas = document.getElementById("pinballCanvas");
      const ctx = canvas.getContext("2d");
      const resultEl = document.getElementById("result");
      const participantsInput = document.getElementById("participantsInput");

      /* ---------------- ëœë¤ ì´ë¦„ ìƒì„± ---------------- */
      function generateRandomNames(count = 3) {
        const funnyNames = [
          "ë˜‘ë˜‘",
          "ë©ë©",
          "ì•¼ì˜¹",
          "ê¼¬ê¼¬",
          "ì§¹ì§¹",
          "í­í’",
          "ë²ˆê°œ",
          "ë¶ˆê½ƒ",
          "êµ¬ë¦„",
          "ë³„ë¹›",
          "ë‹¬ë‹˜",
          "íƒœì–‘",
          "ë°”ëŒ",
          "ìš°ì£¼",
          "ë¡œë´‡",
          "í† ë¥´",
          "í—í¬",
          "ë¸”ë™",
          "ë ˆë“œ",
          "ë¸”ë£¨",
          "ê·¸ë¦°",
          "í•‘í¬",
          "ê³¨ë“œ",
          "ì‹¤ë²„",
          "ë‹¤ì´ì•„",
          "ë¼ë©´",
          "ê¹€ì¹˜",
          "ì¹˜í‚¨",
          "í”¼ì",
          "ì½œë¼",
          "ì»¤í”¼",
          "ì£¼ìŠ¤",
          "ìš°ìœ ",
          "í¬ë„",
          "ì‚¬ê³¼",
          "ë”¸ê¸°",
          "ìˆ˜ë°•",
          "ë©œë¡ ",
          "ë³µìˆ­",
          "ì²´ë¦¬",
          "í˜¸ë‘",
          "ì‚¬ì",
          "ê³°ëŒ",
          "í­ê·„",
          "ë‹¤ëŒ",
          "ê³ ì–‘",
          "ê°•ì•„",
          "í–„ìŠ¤",
          "í† ë¼",
          "ëŒê³ ë˜",
          "ìƒì–´",
          "ë¬¸ì–´",
          "ë¶ˆê°€",
          "ì˜¤ë¦¬",
          "ê±°ë¶",
          "ë‚˜ë¹„",
          "ë²Œ",
          "ì ì",
          "ê°œêµ¬",
          "ë„ë§ˆ",
          "ë±€",
          "ë„ë§ˆ",
          "ì¹˜íƒ€",
          "ê¸°ë¦°",
          "ì½”ë¼",
          "ì¥",
          "ë¼ì§€",
          "ì†Œ",
          "ì–‘",
          "ë§",
          "ë‹­",
          "ê°œ",
          "ê³ ì–‘",
          "ì›ìˆ­",
          "íŒ¬ë”",
        ];

        const shuffled = [...funnyNames].sort(() => Math.random() - 0.5);
        return shuffled.slice(0, count).join(" ");
      }

      /* ---------------- ì°¸ê°€ì íŒŒì‹± ---------------- */
      function parseParticipants(text) {
        const lines = text
          .split(/[\s\n]+/)
          .map((s) => s.trim())
          .filter((s) => s);
        const result = [];

        lines.forEach((line) => {
          let name = line;
          let count = 1;

          // ìˆ«ìë¡œ ê°œìˆ˜ ì§€ì • (ì² ìˆ˜2)
          const numMatch = line.match(/^(.+?)(\d+)$/);
          if (numMatch) {
            name = numMatch[1];
            count = parseInt(numMatch[2]);
          } else {
            // ë³„í‘œë¡œ ê°œìˆ˜ ì§€ì • (ì˜í¬*3)
            const starMatch = line.match(/^(.+?)\*(\d+)$/);
            if (starMatch) {
              name = starMatch[1];
              count = parseInt(starMatch[2]);
            }
          }

          for (let i = 0; i < count; i++) {
            result.push(name);
          }
        });

        return result;
      }

      /* ---------------- í•€ ì´ˆê¸°í™” ---------------- */
      function initPins() {
        pins = [];
        const pinCount = 50; // ì›í˜• í•€
        const barCount = 25; // ë§‰ëŒ€ê¸° ì¥ì• ë¬¼

        const neonColors = [
          "#ff00ff", // í•‘í¬
          "#00ffff", // ì‹œì•ˆ
          "#ff00ff", // ë§ˆì  íƒ€
          "#00ff00", // ë¼ì„
          "#ffff00", // ì˜ë¡œìš°
          "#ff0080", // í•‘í¬
          "#0080ff", // ë¸”ë£¨
        ];

        // ì¥ì• ë¬¼ ê°„ ìµœì†Œ ê±°ë¦¬ (ê³µì´ ê°‡íˆì§€ ì•Šë„ë¡)
        const minDistance = 60;
        const placedPins = [];

        // ì›í˜• í•€ ë°°ì¹˜ (ê²½ë¡œë¥¼ ë§‰ì§€ ì•Šë„ë¡ ê°œì„ )
        for (let i = 0; i < pinCount; i++) {
          let attempts = 0;
          let valid = false;
          let x, y;

          while (!valid && attempts < 50) {
            x = Math.random() * (canvas.width - 40) + 20;
            y = 150 + Math.random() * (canvas.height - 400);

            // ë‹¤ë¥¸ í•€ê³¼ ì¶©ë¶„í•œ ê±°ë¦¬ ìœ ì§€
            valid = placedPins.every((pin) => {
              const dx = x - pin.x;
              const dy = y - pin.y;
              return Math.sqrt(dx * dx + dy * dy) > minDistance;
            });

            // ì¢Œìš° ê²½ê³„ì—ì„œ ë„ˆë¬´ ê°€ê¹Œì´ ìˆìœ¼ë©´ í”¼í•˜ê¸° (ê²½ë¡œ í™•ë³´)
            if (valid && (x < 50 || x > canvas.width - 50)) {
              valid = Math.random() > 0.3; // ê²½ê³„ ê·¼ì²˜ëŠ” 30% í™•ë¥ ë¡œë§Œ ë°°ì¹˜
            }

            attempts++;
          }

          if (valid) {
            pins.push({
              type: "circle",
              x: x,
              y: y,
              r: 8 + Math.random() * 4,
              color: neonColors[Math.floor(Math.random() * neonColors.length)],
              glow: Math.random() * 0.5 + 0.5,
            });
            placedPins.push({ x, y });
          }
        }

        // ê¸°ìš¸ì–´ì§„ ë§‰ëŒ€ê¸° ì¥ì• ë¬¼ (ì•„ë˜ë¡œ ê°€ëŠ” ê²½ë¡œ í™•ë³´)
        for (let i = 0; i < barCount; i++) {
          let attempts = 0;
          let valid = false;
          let x, y, angle;

          while (!valid && attempts < 50) {
            x = Math.random() * (canvas.width - 60) + 30;
            y = 150 + Math.random() * (canvas.height - 400);

            // ëŒ€ë¶€ë¶„ ì•„ë˜ìª½ìœ¼ë¡œ ê¸°ìš¸ì–´ì§€ë„ë¡ (30ë„ ~ 60ë„ ë˜ëŠ” 120ë„ ~ 150ë„)
            // ì´ë ‡ê²Œ í•˜ë©´ ê³µì´ ì•„ë˜ë¡œ ë–¨ì–´ì§€ëŠ” ê²½ë¡œê°€ í™•ë³´ë¨
            const angleType = Math.random();
            if (angleType < 0.5) {
              angle = Math.PI / 6 + Math.random() * (Math.PI / 6); // 30~60ë„
            } else {
              angle = (2 * Math.PI) / 3 + Math.random() * (Math.PI / 6); // 120~150ë„
            }

            // ë‹¤ë¥¸ í•€ê³¼ ì¶©ë¶„í•œ ê±°ë¦¬ ìœ ì§€
            valid = placedPins.every((pin) => {
              const dx = x - pin.x;
              const dy = y - pin.y;
              return Math.sqrt(dx * dx + dy * dy) > minDistance;
            });

            attempts++;
          }

          if (valid) {
            const length = 30 + Math.random() * 40; // ê¸¸ì´ ì¤„ì„
            pins.push({
              type: "bar",
              x: x,
              y: y,
              length: length,
              width: 8,
              angle: angle,
              color: neonColors[Math.floor(Math.random() * neonColors.length)],
            });
            placedPins.push({ x, y });
          }
        }

        // ê²°ìŠ¹ì„  ê·¼ì²˜ íšŒì „ í’ì°¨ ì¥ì• ë¬¼ ì¶”ê°€ (ìŠ¤í™íƒ€í´í•œ íš¨ê³¼)
        const finishLineY = canvas.height - 50;
        const windmillRadius = 70; // í° í’ì°¨
        const centerGap = canvas.width * 0.25; // ì¤‘ì•™ ê³µê°„ í™•ë³´

        // ì¢Œì¸¡ í’ì°¨
        pins.push({
          type: "windmill",
          x: canvas.width * 0.25 - centerGap / 2,
          y: finishLineY - 120,
          radius: windmillRadius,
          angle: Math.random() * Math.PI * 2,
          rotationSpeed: 0.08 + Math.random() * 0.04, // ë¹ ë¥¸ íšŒì „
          color: "#00ffff", // ì‹œì•ˆ
          pullRadius: 100, // ëŒì–´ë‹¹ê¸°ëŠ” ë²”ìœ„
          catchBall: null, // ì¡ì€ ê³µ
          catchAngle: 0, // ê³µì„ ì¡ì€ ê°ë„
          particleEffect: 0, // íŒŒí‹°í´ íš¨ê³¼
        });

        // ìš°ì¸¡ í’ì°¨
        pins.push({
          type: "windmill",
          x: canvas.width * 0.75 + centerGap / 2,
          y: finishLineY - 120,
          radius: windmillRadius,
          angle: Math.random() * Math.PI * 2,
          rotationSpeed: -(0.08 + Math.random() * 0.04), // ë°˜ëŒ€ ë°©í–¥ íšŒì „
          color: "#ff00ff", // í•‘í¬
          pullRadius: 100, // ëŒì–´ë‹¹ê¸°ëŠ” ë²”ìœ„
          catchBall: null, // ì¡ì€ ê³µ
          catchAngle: 0, // ê³µì„ ì¡ì€ ê°ë„
          particleEffect: 0, // íŒŒí‹°í´ íš¨ê³¼
        });

        // ì¤‘ì•™ ì‘ì€ í’ì°¨
        pins.push({
          type: "windmill",
          x: canvas.width / 2, // ì •ì¤‘ì•™
          y: finishLineY - 100, // ì¢Œìš°ë³´ë‹¤ ì¡°ê¸ˆ ìœ„
          radius: 40, // ì‘ì€ í¬ê¸°
          angle: Math.random() * Math.PI * 2,
          rotationSpeed: 0.12 + Math.random() * 0.06, // ë¹ ë¥¸ íšŒì „
          color: "#ffff00", // ë…¸ë€ìƒ‰
          pullRadius: 60, // ì‘ì€ ëŒì–´ë‹¹ê¸°ëŠ” ë²”ìœ„
          catchBall: null, // ì¡ì€ ê³µ
          catchAngle: 0, // ê³µì„ ì¡ì€ ê°ë„
          particleEffect: 0, // íŒŒí‹°í´ íš¨ê³¼
        });

        // ì—‘ìŠ¤íŠ¸ë¼ ìƒˆ ì´ˆê¸°í™” (ëœë¤ 1ë§ˆë¦¬)
        if (Math.random() < 1.0) {
          // í•­ìƒ 1ë§ˆë¦¬ (100% í™•ë¥ )
          bird = {
            x: Math.random() * (canvas.width - 100) + 50,
            y: 200 + Math.random() * (canvas.height - 600), // ì¤‘ê°„ êµ¬ê°„ì— ë°°ì¹˜
            vx: (Math.random() - 0.5) * 1.5, // ì¢Œìš° ì´ë™ ì†ë„
            vy: Math.sin(Math.random() * Math.PI * 2) * 0.3, // ìƒí•˜ ì‚´ì§ ì›€ì§ì„
            size: 25 + Math.random() * 15, // ìƒˆ í¬ê¸°
            wingFlap: 0, // ë‚ ê°œ í„ëŸ­ì„ ì• ë‹ˆë©”ì´ì…˜
            color: neonColors[Math.floor(Math.random() * neonColors.length)],
            direction: Math.random() > 0.5 ? 1 : -1, // ì¢Œìš° ë°©í–¥
          };
        }
      }

      /* ---------------- ê³µ ì´ˆê¸°í™” ---------------- */
      function initBalls() {
        balls = [];
        const shuffled = [...participants].sort(() => Math.random() - 0.5);

        const neonColors = [
          "#ff00ff",
          "#00ffff",
          "#ff0080",
          "#00ff00",
          "#ffff00",
          "#ff00ff",
          "#0080ff",
          "#ff8000",
        ];

        shuffled.forEach((name, i) => {
          balls.push({
            name,
            x: canvas.width / 2 + (Math.random() - 0.5) * 40,
            y: 20,
            r: 14,
            vx: (Math.random() - 0.5) * 2,
            vy: 0,
            finished: false,
            finishOrder: null,
            color: neonColors[i % neonColors.length],
            lastY: 20, // ë§ˆì§€ë§‰ y ìœ„ì¹˜ ì¶”ì 
            stuckFrames: 0, // ê°™ì€ ìœ„ì¹˜ì— ë¨¸ë¬¸ í”„ë ˆì„ ìˆ˜
            nearbyPin: null, // ê·¼ì²˜ì— ìˆëŠ” ì¥ì• ë¬¼
            nearbyPinFrames: 0, // ê°™ì€ ì¥ì• ë¬¼ ê·¼ì²˜ì— ë¨¸ë¬¸ í”„ë ˆì„ ìˆ˜
          });
        });
      }

      /* ---------------- í•€ ê·¸ë¦¬ê¸° (ë„¤ì˜¨ íš¨ê³¼) ---------------- */
      function drawPin(pin) {
        ctx.shadowBlur = 15;
        ctx.shadowColor = pin.color;

        if (pin.type === "circle") {
          ctx.beginPath();
          ctx.arc(pin.x, pin.y, pin.r, 0, Math.PI * 2);
          ctx.fillStyle = pin.color;
          ctx.fill();

          ctx.strokeStyle = pin.color;
          ctx.lineWidth = 2;
          ctx.stroke();

          // ë‚´ë¶€ í•˜ì´ë¼ì´íŠ¸
          ctx.beginPath();
          ctx.arc(
            pin.x - pin.r * 0.3,
            pin.y - pin.r * 0.3,
            pin.r * 0.4,
            0,
            Math.PI * 2
          );
          ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
          ctx.fill();
        } else if (pin.type === "bar") {
          // íšŒì „ëœ ë§‰ëŒ€ê¸° ê·¸ë¦¬ê¸°
          ctx.save();
          ctx.translate(pin.x, pin.y);
          ctx.rotate(pin.angle);

          ctx.fillStyle = pin.color;
          ctx.fillRect(-pin.length / 2, -pin.width / 2, pin.length, pin.width);
          ctx.strokeStyle = pin.color;
          ctx.lineWidth = 2;
          ctx.strokeRect(
            -pin.length / 2,
            -pin.width / 2,
            pin.length,
            pin.width
          );

          ctx.restore();
        } else if (pin.type === "windmill") {
          // íšŒì „í•˜ëŠ” í’ì°¨ ê·¸ë¦¬ê¸° (ìŠ¤í™íƒ€í´ ë²„ì „)
          ctx.save();
          ctx.translate(pin.x, pin.y);
          ctx.rotate(pin.angle);

          // ëŒì–´ë‹¹ê¸°ëŠ” ë²”ìœ„ ê¸€ë¡œìš° íš¨ê³¼
          if (pin.particleEffect > 0) {
            ctx.shadowBlur = 30 + pin.particleEffect * 5;
            ctx.shadowColor = pin.color;
            ctx.beginPath();
            ctx.arc(0, 0, pin.radius + 10, 0, Math.PI * 2);
            ctx.strokeStyle = pin.color + "60";
            ctx.lineWidth = 3;
            ctx.stroke();
          }

          // í’ì°¨ ë‚ ê°œ 4ê°œ (ë” í™”ë ¤í•˜ê²Œ)
          for (let i = 0; i < 4; i++) {
            ctx.save();
            ctx.rotate((Math.PI / 2) * i);

            // ë‚ ê°œ ê·¸ë¼ë””ì–¸íŠ¸
            const gradient = ctx.createLinearGradient(0, 0, pin.radius, 0);
            gradient.addColorStop(0, pin.color + "FF");
            gradient.addColorStop(1, pin.color + "80");

            // ë‚ ê°œ ê·¸ë¦¬ê¸°
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(pin.radius, -pin.radius * 0.4);
            ctx.lineTo(pin.radius * 0.9, 0);
            ctx.lineTo(pin.radius * 0.7, pin.radius * 0.1);
            ctx.closePath();
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = pin.color;
            ctx.lineWidth = 5;
            ctx.stroke();

            // ë‚ ê°œ í•˜ì´ë¼ì´íŠ¸
            ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
            ctx.fill();

            ctx.restore();
          }

          // ì¤‘ì‹¬ ì› (ë” í¬ê³  í™”ë ¤í•˜ê²Œ)
          const centerGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 15);
          centerGradient.addColorStop(0, "#fff");
          centerGradient.addColorStop(1, pin.color);
          ctx.beginPath();
          ctx.arc(0, 0, 15, 0, Math.PI * 2);
          ctx.fillStyle = centerGradient;
          ctx.fill();
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 4;
          ctx.stroke();

          ctx.restore();

          // ëŒì–´ë‹¹ê¸°ëŠ” ë²”ìœ„ í‘œì‹œ (ë°˜íˆ¬ëª… ì›)
          ctx.save();
          ctx.globalAlpha = 0.2;
          ctx.beginPath();
          ctx.arc(pin.x, pin.y, pin.pullRadius, 0, Math.PI * 2);
          ctx.strokeStyle = pin.color;
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.restore();

          // í’ì°¨ì— ì¡í˜€ìˆëŠ” ê³µ ê·¸ë¦¬ê¸° (í’ì°¨ì™€ í•¨ê»˜ íšŒì „)
          if (pin.catchBall && !pin.catchBall.finished) {
            ctx.save();
            ctx.translate(pin.x, pin.y);
            ctx.rotate(pin.catchAngle);

            // ê³µ ìœ„ì¹˜
            const ballX = Math.cos(0) * (pin.radius + pin.catchBall.r);
            const ballY = Math.sin(0) * (pin.radius + pin.catchBall.r);
            ctx.translate(ballX, ballY);

            // ê³µ ê·¸ë¦¬ê¸° (íšŒì „ëœ ìƒíƒœ)
            ctx.shadowBlur = 25;
            ctx.shadowColor = pin.catchBall.color;
            ctx.beginPath();
            ctx.arc(0, 0, pin.catchBall.r, 0, Math.PI * 2);
            const gradient = ctx.createRadialGradient(
              0,
              0,
              0,
              0,
              0,
              pin.catchBall.r
            );
            gradient.addColorStop(0, pin.catchBall.color + "FF");
            gradient.addColorStop(1, pin.catchBall.color + "CC");
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = pin.catchBall.color;
            ctx.lineWidth = 3;
            ctx.stroke();

            // ê³µ ì´ë¦„
            ctx.shadowBlur = 10;
            ctx.fillStyle = "#fff";
            ctx.font = "bold 11px sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(pin.catchBall.name.slice(0, 2), 0, 2);

            ctx.restore();
          }
        }

        ctx.shadowBlur = 0;
      }

      /* ---------------- ê³µ ê·¸ë¦¬ê¸° (ë„¤ì˜¨ íš¨ê³¼) ---------------- */
      function drawBall(ball) {
        // ê¸€ë¡œìš° íš¨ê³¼
        ctx.shadowBlur = 20;
        ctx.shadowColor = ball.color;

        // ì™¸ê³½ ê¸€ë¡œìš°
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r + 3, 0, Math.PI * 2);
        ctx.fillStyle = ball.color + "40";
        ctx.fill();

        // ë©”ì¸ ê³µ
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
        const gradient = ctx.createRadialGradient(
          ball.x - ball.r * 0.3,
          ball.y - ball.r * 0.3,
          0,
          ball.x,
          ball.y,
          ball.r
        );
        gradient.addColorStop(0, ball.color + "FF");
        gradient.addColorStop(1, ball.color + "CC");
        ctx.fillStyle = gradient;
        ctx.fill();

        ctx.strokeStyle = ball.color;
        ctx.lineWidth = 2;
        ctx.stroke();

        // í•˜ì´ë¼ì´íŠ¸
        ctx.beginPath();
        ctx.arc(
          ball.x - ball.r * 0.3,
          ball.y - ball.r * 0.3,
          ball.r * 0.4,
          0,
          Math.PI * 2
        );
        ctx.fillStyle = "rgba(255, 255, 255, 0.7)";
        ctx.fill();

        ctx.shadowBlur = 0;

        // ì´ë¦„ í‘œì‹œ (ë„¤ì˜¨ í…ìŠ¤íŠ¸) - ì „ì²´ ì´ë¦„ í‘œì‹œ
        ctx.shadowBlur = 10;
        ctx.shadowColor = ball.color;
        ctx.fillStyle = "#fff";

        // ì´ë¦„ ê¸¸ì´ì— ë”°ë¼ í°íŠ¸ í¬ê¸° ì¡°ì •
        const nameLength = ball.name.length;
        let fontSize = 12;
        if (nameLength > 6) {
          fontSize = 8;
        } else if (nameLength > 4) {
          fontSize = 9;
        } else if (nameLength > 3) {
          fontSize = 10;
        } else if (nameLength > 2) {
          fontSize = 11;
        }

        ctx.font = `bold ${fontSize}px sans-serif`;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        // ê¸´ ì´ë¦„ì€ ì—¬ëŸ¬ ì¤„ë¡œ í‘œì‹œ
        if (nameLength > 4) {
          // ë‘ ì¤„ë¡œ ë‚˜ëˆ„ê¸°
          const mid = Math.ceil(nameLength / 2);
          ctx.fillText(ball.name.slice(0, mid), ball.x, ball.y - 4);
          ctx.fillText(ball.name.slice(mid), ball.x, ball.y + 5);
        } else {
          // ì§§ì€ ì´ë¦„ì€ í•œ ì¤„ë¡œ ì „ì²´ í‘œì‹œ
          ctx.fillText(ball.name, ball.x, ball.y + 2);
        }
        ctx.shadowBlur = 0;
      }

      /* ---------------- ìƒˆ ê·¸ë¦¬ê¸° (ì›ƒê¸´ ìƒˆ) ---------------- */
      function drawBird(bird) {
        ctx.save();
        ctx.translate(bird.x, bird.y);
        ctx.scale(bird.direction, 1); // ì¢Œìš° ë°©í–¥ì— ë”°ë¼ ë’¤ì§‘ê¸°

        ctx.shadowBlur = 15;
        ctx.shadowColor = bird.color;

        // ë‚ ê°œ í„ëŸ­ì„ ì• ë‹ˆë©”ì´ì…˜
        bird.wingFlap += 0.3;
        const wingAngle = Math.sin(bird.wingFlap) * 0.3;

        // ëª¸í†µ (íƒ€ì›)
        ctx.fillStyle = bird.color;
        ctx.beginPath();
        ctx.ellipse(0, 0, bird.size * 0.4, bird.size * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = bird.color;
        ctx.lineWidth = 2;
        ctx.stroke();

        // ë¨¸ë¦¬ (ì›)
        ctx.beginPath();
        ctx.arc(
          bird.size * 0.5,
          -bird.size * 0.2,
          bird.size * 0.3,
          0,
          Math.PI * 2
        );
        ctx.fill();
        ctx.stroke();

        // ë¶€ë¦¬ (ì‚¼ê°í˜• - ì›ƒê¸´ ëª¨ì–‘)
        ctx.fillStyle = "#ffff00";
        ctx.beginPath();
        ctx.moveTo(bird.size * 0.7, -bird.size * 0.2);
        ctx.lineTo(bird.size * 1.0, -bird.size * 0.1);
        ctx.lineTo(bird.size * 0.7, 0);
        ctx.closePath();
        ctx.fill();

        // ëˆˆ (í° ëˆˆ)
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(
          bird.size * 0.55,
          -bird.size * 0.25,
          bird.size * 0.08,
          0,
          Math.PI * 2
        );
        ctx.fill();
        ctx.fillStyle = "#000";
        ctx.beginPath();
        ctx.arc(
          bird.size * 0.57,
          -bird.size * 0.27,
          bird.size * 0.05,
          0,
          Math.PI * 2
        );
        ctx.fill();

        // ì™¼ìª½ ë‚ ê°œ (í„ëŸ­ì„)
        ctx.save();
        ctx.rotate(wingAngle);
        ctx.fillStyle = bird.color;
        ctx.beginPath();
        ctx.ellipse(
          -bird.size * 0.3,
          0,
          bird.size * 0.25,
          bird.size * 0.4,
          -0.5,
          0,
          Math.PI * 2
        );
        ctx.fill();
        ctx.stroke();
        ctx.restore();

        // ì˜¤ë¥¸ìª½ ë‚ ê°œ (í„ëŸ­ì„)
        ctx.save();
        ctx.rotate(-wingAngle);
        ctx.fillStyle = bird.color;
        ctx.beginPath();
        ctx.ellipse(
          bird.size * 0.3,
          0,
          bird.size * 0.25,
          bird.size * 0.4,
          0.5,
          0,
          Math.PI * 2
        );
        ctx.fill();
        ctx.stroke();
        ctx.restore();

        // ê¼¬ë¦¬
        ctx.fillStyle = bird.color;
        ctx.beginPath();
        ctx.ellipse(
          -bird.size * 0.5,
          bird.size * 0.2,
          bird.size * 0.15,
          bird.size * 0.3,
          0.3,
          0,
          Math.PI * 2
        );
        ctx.fill();
        ctx.stroke();

        ctx.restore();
        ctx.shadowBlur = 0;
      }

      /* ---------------- ì¶©ëŒ ê°ì§€ ---------------- */
      function checkCollision(ball, pin) {
        if (pin.type === "circle") {
          const dx = ball.x - pin.x;
          const dy = ball.y - pin.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          return distance < ball.r + pin.r;
        } else if (pin.type === "bar") {
          // íšŒì „ëœ ë§‰ëŒ€ê¸°ì™€ ê³µì˜ ì¶©ëŒ ê°ì§€
          const dx = ball.x - pin.x;
          const dy = ball.y - pin.y;
          const cos = Math.cos(-pin.angle);
          const sin = Math.sin(-pin.angle);
          const localX = dx * cos - dy * sin;
          const localY = dx * sin + dy * cos;

          const closestX = Math.max(
            -pin.length / 2,
            Math.min(localX, pin.length / 2)
          );
          const closestY = Math.max(
            -pin.width / 2,
            Math.min(localY, pin.width / 2)
          );

          const distX = localX - closestX;
          const distY = localY - closestY;
          return distX * distX + distY * distY < ball.r * ball.r;
        } else if (pin.type === "windmill") {
          // í’ì°¨ì™€ ê³µì˜ ì¶©ëŒ ê°ì§€ (í’ì°¨ ë°˜ì§€ë¦„ ë‚´)
          const dx = ball.x - pin.x;
          const dy = ball.y - pin.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          return distance < ball.r + pin.radius;
        }
        return false;
      }

      /* ---------------- ì¹´ë©”ë¼ ì—…ë°ì´íŠ¸ ---------------- */
      function updateCamera() {
        if (balls.length === 0) return;

        // 1ìœ„ ê³µ (ê°€ì¥ yê°’ì´ í° ê³µ = ê°€ì¥ ì•ì„  ê³µ) ì°¾ê¸°
        const activeBalls = balls.filter((b) => !b.finished);
        if (activeBalls.length > 0) {
          // ê°€ì¥ ì•ì„  ê³µ ì°¾ê¸°
          const leadingBall = activeBalls.reduce((prev, curr) =>
            curr.y > prev.y ? curr : prev
          );

          // íƒ€ê²Ÿ ì¹´ë©”ë¼ ìœ„ì¹˜ ì„¤ì •
          targetCameraY = Math.max(
            0,
            Math.min(
              leadingBall.y - canvasContainer.clientHeight / 2,
              canvas.height - canvasContainer.clientHeight
            )
          );

          // ë¶€ë“œëŸ¬ìš´ ì¹´ë©”ë¼ ì´ë™ (lerp)
          const lerpFactor = 0.1; // 0.1 = ë¶€ë“œëŸ½ê²Œ, 1.0 = ì¦‰ì‹œ
          cameraY += (targetCameraY - cameraY) * lerpFactor;
        }
      }

      /* ---------------- ì• ë‹ˆë©”ì´ì…˜ ---------------- */
      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // ì¹´ë©”ë¼ ë³€í™˜
        ctx.save();
        ctx.translate(0, -cameraY);

        // ë°°ê²½ ê·¸ë¦¬ë“œ (ë„¤ì˜¨ íš¨ê³¼)
        ctx.strokeStyle = "#00ffff22";
        ctx.lineWidth = 1;
        for (let i = 0; i < canvas.width; i += 50) {
          ctx.beginPath();
          ctx.moveTo(i, 0);
          ctx.lineTo(i, canvas.height);
          ctx.stroke();
        }
        for (let i = 0; i < canvas.height; i += 50) {
          ctx.beginPath();
          ctx.moveTo(0, i);
          ctx.lineTo(canvas.width, i);
          ctx.stroke();
        }

        // í’ì°¨ íšŒì „ ì—…ë°ì´íŠ¸ ë° ê³µ ëŒì–´ë‹¹ê¸°ê¸°/ë˜ì§€ê¸°
        pins.forEach((pin) => {
          if (pin.type === "windmill") {
            // íšŒì „ ì—…ë°ì´íŠ¸
            pin.angle += pin.rotationSpeed;
            if (pin.angle > Math.PI * 2) {
              pin.angle -= Math.PI * 2;
            }

            // ê³µì„ ì¡ê³  ìˆëŠ” ê²½ìš°
            if (pin.catchBall && !pin.catchBall.finished) {
              pin.catchAngle += pin.rotationSpeed * 1.5; // ê³µë„ í•¨ê»˜ íšŒì „

              // ê³µì„ í’ì°¨ ì£¼ë³€ì— ìœ„ì¹˜ì‹œí‚¤ê¸°
              pin.catchBall.x =
                pin.x +
                Math.cos(pin.catchAngle) * (pin.radius + pin.catchBall.r);
              pin.catchBall.y =
                pin.y +
                Math.sin(pin.catchAngle) * (pin.radius + pin.catchBall.r);

              // ê³µ ì†ë„ ì œê±° (í’ì°¨ê°€ ì¡ê³  ìˆìŒ)
              pin.catchBall.vx *= 0.9;
              pin.catchBall.vy *= 0.9;

              // 0.5ì´ˆ í›„ ë˜ì§€ê¸° (ìŠ¤í™íƒ€í´!)
              if (pin.catchAngle > pin.angle + Math.PI) {
                const throwSpeed = Math.abs(pin.rotationSpeed) * 100; // íšŒì „ ì†ë„ì— ë¹„ë¡€
                pin.catchBall.vx = Math.cos(pin.catchAngle) * throwSpeed;
                pin.catchBall.vy = Math.sin(pin.catchAngle) * throwSpeed - 5; // ìœ„ë¡œ ê°•í•˜ê²Œ

                pin.particleEffect = 30; // íŒŒí‹°í´ íš¨ê³¼
                pin.catchBall = null;
                playSound("finish");
                vibrate([50, 30, 50]);
              }
            }

            // íŒŒí‹°í´ íš¨ê³¼ ê°ì†Œ
            if (pin.particleEffect > 0) {
              pin.particleEffect--;
            }
          }
        });

        // ìƒˆ ì›€ì§ì„ ì—…ë°ì´íŠ¸
        if (bird) {
          bird.x += bird.vx;
          bird.y += bird.vy;

          // ì¢Œìš° ê²½ê³„ì—ì„œ ë°˜ì‚¬
          if (bird.x < bird.size || bird.x > canvas.width - bird.size) {
            bird.vx *= -1;
            bird.direction *= -1; // ë°©í–¥ ì „í™˜
            bird.x = Math.max(
              bird.size,
              Math.min(canvas.width - bird.size, bird.x)
            );
          }

          // ìƒí•˜ ê²½ê³„ì—ì„œ ë°˜ì‚¬ (ì‚´ì§ë§Œ)
          if (
            bird.y < bird.size * 2 ||
            bird.y > canvas.height - bird.size * 3
          ) {
            bird.vy *= -0.5;
            bird.y = Math.max(
              bird.size * 2,
              Math.min(canvas.height - bird.size * 3, bird.y)
            );
          }

          // ìì—°ìŠ¤ëŸ¬ìš´ ì¢Œìš° ë°°íšŒ (ì†ë„ ë³€í™”)
          bird.vx += (Math.random() - 0.5) * 0.05;
          bird.vx = Math.max(-2.0, Math.min(2.0, bird.vx)); // ìµœëŒ€ ì†ë„ ì œí•œ

          // ìƒí•˜ ì‚´ì§ ì›€ì§ì„
          bird.vy += (Math.random() - 0.5) * 0.02;
          bird.vy = Math.max(-0.5, Math.min(0.5, bird.vy));
        }

        // ìƒˆ ê·¸ë¦¬ê¸°
        if (bird) {
          drawBird(bird);
        }

        // í•€ ê·¸ë¦¬ê¸°
        pins.forEach((pin) => drawPin(pin));

        // ê²°ìŠ¹ì„  (ì˜¤ëª©í•œ ê³¡ì„ , ë„¤ì˜¨ íš¨ê³¼)
        const finishBaseY = canvas.height - 50;
        const finishDepth = 40; // ì˜¤ëª©í•œ ì •ë„ (í´ìˆ˜ë¡ ë” ì˜¤ëª©)
        const finishWidth = canvas.width;
        const finishCenterX = finishWidth / 2;

        ctx.shadowBlur = 20;
        ctx.shadowColor = "#ffff00";
        ctx.strokeStyle = "#ffff00";
        ctx.lineWidth = 5;
        ctx.setLineDash([20, 10]);
        ctx.beginPath();

        // ì˜¤ëª©í•œ ê³¡ì„  ê·¸ë¦¬ê¸° (í¬ë¬¼ì„  í˜•íƒœ)
        for (let x = 0; x <= finishWidth; x += 2) {
          const normalizedX = x / finishWidth; // 0 ~ 1
          const curve = 4 * normalizedX * (1 - normalizedX); // 0~1 ì‚¬ì´ì˜ ê³¡ì„  (ì¤‘ê°„ì´ 1, ì–‘ ëì´ 0)
          const y = finishBaseY + finishDepth * curve;

          if (x === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }

        ctx.stroke();
        ctx.setLineDash([]);
        ctx.shadowBlur = 0;

        // FINISH í…ìŠ¤íŠ¸ (ë„¤ì˜¨ íš¨ê³¼)
        ctx.shadowBlur = 25;
        ctx.shadowColor = "#ffff00";
        ctx.fillStyle = "#ffff00";
        ctx.font = "bold 28px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("FINISH", canvas.width / 2, finishBaseY - 70);
        ctx.shadowBlur = 0;

        // ì¤‘ë ¥ ì ìš©
        balls.forEach((ball) => {
          if (ball.finished) return;

          // ì¤‘ë ¥ ê°•í™” (í•­ìƒ ì•„ë˜ë¡œ ë–¨ì–´ì§€ë„ë¡)
          ball.vy += 0.5; // ì¤‘ë ¥ ì¦ê°€
          ball.x += ball.vx;
          ball.y += ball.vy;

          // ê³µì´ ê°™ì€ ìœ„ì¹˜ì— ë¨¸ë¬´ëŠ”ì§€ ì²´í¬ (ë” ë¯¼ê°í•˜ê²Œ)
          if (Math.abs(ball.y - ball.lastY) < 1.5) {
            ball.stuckFrames++;
          } else {
            ball.stuckFrames = 0;
          }
          ball.lastY = ball.y;

          // ê³µì´ ë„ˆë¬´ ì˜¤ë˜ ê°™ì€ ìœ„ì¹˜ì— ìˆìœ¼ë©´ ê°•ì œë¡œ ì•„ë˜ë¡œ ë°€ê¸° (ë” ë¹ ë¥´ê²Œ ê°ì§€)
          if (ball.stuckFrames > 30) {
            // ì•½ 0.5ì´ˆ ë™ì•ˆ ì›€ì§ì´ì§€ ì•Šìœ¼ë©´ ì¦‰ì‹œ ì•„ë˜ë¡œ
            ball.vy = Math.max(ball.vy, 4.0); // ê°•ì œë¡œ ì•„ë˜ë¡œ ë°€ê¸° (ë” ê°•í•˜ê²Œ)
            ball.vx += (Math.random() - 0.5) * 2.0; // ëœë¤ ìˆ˜í‰ ì´ë™
            ball.stuckFrames = 0;
          }

          // ê²°ìŠ¹ì„  ê·¼ì²˜ì—ì„œëŠ” ë©ˆì¶¤ ê°ì§€ë¥¼ ë” ë¹ ë¥´ê²Œ
          const finishLineY2 = canvas.height - 50;
          if (ball.y > finishLineY2 - 150 && ball.stuckFrames > 15) {
            ball.vy = Math.max(ball.vy, 5.0);
            ball.vx += (Math.random() - 0.5) * 2.5;
            ball.stuckFrames = 0;
          }

          // í•­ìƒ ì•„ë˜ ë°©í–¥ ìµœì†Œ ì†ë„ ë³´ì¥ (ë§¤ í”„ë ˆì„ ì²´í¬, ë” ê°•í™”)
          // ìœ„ë¡œ ì˜¬ë¼ê°€ëŠ” ê²ƒë„ ì¼ì • ì‹œê°„ í›„ì—ëŠ” ì•„ë˜ë¡œ ê°•ì œ
          if (ball.vy < -1 && ball.stuckFrames > 20) {
            ball.vy = 0.5; // ìœ„ë¡œ ì˜¬ë¼ê°€ëŠ” ê²ƒë„ ì œí•œ
          }
          if (ball.vy < 0.8) {
            ball.vy = Math.max(ball.vy, 0.8); // í•­ìƒ ì•„ë˜ë¡œ ìµœì†Œ 0.8 ì†ë„
          }

          // ê³µì´ ë„ˆë¬´ ëŠë ¤ì§€ë©´ ê°•ì œë¡œ ì†ë„ ì¦ê°€ (ë©ˆì¶”ì§€ ì•Šë„ë¡, ë” ê°•í™”)
          const currentSpeed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
          if (currentSpeed < 1.5) {
            // ì „ì²´ ì†ë„ê°€ ë„ˆë¬´ ëŠë¦¬ë©´ ì•„ë˜ ë°©í–¥ìœ¼ë¡œ ê°€ì†
            if (ball.vy < 1.5) {
              ball.vy = 1.5; // ì•„ë˜ ë°©í–¥ ìµœì†Œ ì†ë„ 1.5
            }
            // ì•½ê°„ì˜ ëœë¤ ìˆ˜í‰ ì›€ì§ì„ ì¶”ê°€
            if (Math.abs(ball.vx) < 0.3) {
              ball.vx += (Math.random() - 0.5) * 1.0;
            }
          }

          // ì¥ì• ë¬¼ ê·¼ì²˜ì— ë¨¸ë¬´ëŠ” ì‹œê°„ ì¶”ì  (ë‚‘ê¹€ ë°©ì§€)
          let nearestPin = null;
          let nearestDistance = Infinity;

          pins.forEach((pin) => {
            let distance;
            if (pin.type === "circle") {
              const dx = ball.x - pin.x;
              const dy = ball.y - pin.y;
              distance = Math.sqrt(dx * dx + dy * dy) - ball.r - pin.r;
            } else if (pin.type === "bar") {
              const dx = ball.x - pin.x;
              const dy = ball.y - pin.y;
              distance = Math.sqrt(dx * dx + dy * dy) - ball.r - pin.length / 2;
            } else if (pin.type === "windmill") {
              const dx = ball.x - pin.x;
              const dy = ball.y - pin.y;
              distance = Math.sqrt(dx * dx + dy * dy) - ball.r - pin.radius;
            }

            // ê³µ ê·¼ì²˜(30px ì´ë‚´) ì¥ì• ë¬¼ ì°¾ê¸°
            if (distance < 30 && distance < nearestDistance) {
              nearestDistance = distance;
              nearestPin = pin;
            }
          });

          // ê°™ì€ ì¥ì• ë¬¼ ê·¼ì²˜ì— ìˆëŠ”ì§€ ì²´í¬
          if (nearestPin && ball.nearbyPin === nearestPin) {
            ball.nearbyPinFrames++;

            // 2ì´ˆ(120í”„ë ˆì„) ì´ìƒ ê°™ì€ ì¥ì• ë¬¼ ê·¼ì²˜ì— ìˆìœ¼ë©´ ì œê±°
            if (ball.nearbyPinFrames > 120) {
              const index = pins.indexOf(nearestPin);
              if (index > -1) {
                pins.splice(index, 1);
                playSound("finish"); // ì œê±° íš¨ê³¼ìŒ
                vibrate(30);
              }
              ball.nearbyPin = null;
              ball.nearbyPinFrames = 0;
            }
          } else {
            // ë‹¤ë¥¸ ì¥ì• ë¬¼ì´ê±°ë‚˜ ì¥ì• ë¬¼ì´ ì—†ìœ¼ë©´ ì´ˆê¸°í™”
            ball.nearbyPin = nearestPin;
            ball.nearbyPinFrames = nearestPin ? 1 : 0;
          }

          // í•€ê³¼ ì¶©ëŒ
          pins.forEach((pin) => {
            if (checkCollision(ball, pin)) {
              if (pin.type === "circle") {
                const dx = ball.x - pin.x;
                const dy = ball.y - pin.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > 0) {
                  // íŠ•ê¸°ê¸°
                  const overlap = ball.r + pin.r - distance;
                  ball.x += (dx / distance) * overlap * 1.1;
                  ball.y += (dy / distance) * overlap * 1.1;

                  const angle = Math.atan2(dy, dx);
                  const speed = Math.sqrt(
                    ball.vx * ball.vx + ball.vy * ball.vy
                  );
                  const bounceForce = speed * 0.6; // íŠ•ê¹€ í˜ ì¤„ì„
                  ball.vx = Math.cos(angle) * bounceForce;
                  ball.vy = Math.sin(angle) * bounceForce;

                  // ìœ„ë¡œ ë„ˆë¬´ íŠ•ê¸°ëŠ” ê²ƒ ë°©ì§€ (ì•„ë˜ ë°©í–¥ ì†ë„ ìš°ì„ )
                  if (ball.vy < 0) {
                    ball.vy = Math.max(ball.vy, -0.5); // ìœ„ë¡œ ìµœëŒ€ 0.5ê¹Œì§€ë§Œ (ë” ì œí•œ)
                  }
                  // í•­ìƒ ì•„ë˜ë¡œ ë–¨ì–´ì§€ë„ë¡ ë³´ì¥ (ê°•í™”)
                  if (ball.vy < 0.5) {
                    ball.vy = 0.5; // ìµœì†Œ ì•„ë˜ ë°©í–¥ ì†ë„ ë³´ì¥
                  }

                  playSound("bounce");
                  vibrate(10);
                }
              } else if (pin.type === "bar") {
                // íšŒì „ëœ ë§‰ëŒ€ê¸° ì¶©ëŒ - ë‚‘ê¹€ ë°©ì§€ ê°•í™”
                const dx = ball.x - pin.x;
                const dy = ball.y - pin.y;
                const cos = Math.cos(-pin.angle);
                const sin = Math.sin(-pin.angle);
                const localX = dx * cos - dy * sin;
                const localY = dx * sin + dy * cos;

                const closestX = Math.max(
                  -pin.length / 2,
                  Math.min(localX, pin.length / 2)
                );
                const closestY = Math.max(
                  -pin.width / 2,
                  Math.min(localY, pin.width / 2)
                );

                const worldClosestX = pin.x + closestX * cos - closestY * sin;
                const worldClosestY = pin.y + closestX * sin + closestY * cos;

                const distX = ball.x - worldClosestX;
                const distY = ball.y - worldClosestY;
                const distance = Math.sqrt(distX * distX + distY * distY);

                if (distance > 0) {
                  const overlap = ball.r - distance;

                  // ë‚‘ê¹€ ë°©ì§€: ì—¬ëŸ¬ ë²ˆ ë³´ì •í•˜ì—¬ í™•ì‹¤íˆ ë°–ìœ¼ë¡œ ë°€ì–´ë‚´ê¸°
                  if (overlap > 0) {
                    // 1ì°¨ ë³´ì • (ë” ê°•í•˜ê²Œ)
                    const pushDistance = overlap * 1.5;
                    ball.x += (distX / distance) * pushDistance;
                    ball.y += (distY / distance) * pushDistance;

                    // 2ì°¨ ë³´ì •: ë‹¤ì‹œ í™•ì¸í•˜ì—¬ ì—¬ì „íˆ ì•ˆìª½ì— ìˆìœ¼ë©´ ì¶”ê°€ë¡œ ë°€ì–´ë‚´ê¸°
                    const dx2 = ball.x - pin.x;
                    const dy2 = ball.y - pin.y;
                    const localX2 = dx2 * cos - dy2 * sin;
                    const localY2 = dx2 * sin + dy2 * cos;
                    const closestX2 = Math.max(
                      -pin.length / 2,
                      Math.min(localX2, pin.length / 2)
                    );
                    const closestY2 = Math.max(
                      -pin.width / 2,
                      Math.min(localY2, pin.width / 2)
                    );
                    const worldClosestX2 =
                      pin.x + closestX2 * cos - closestY2 * sin;
                    const worldClosestY2 =
                      pin.y + closestX2 * sin + closestY2 * cos;
                    const distX2 = ball.x - worldClosestX2;
                    const distY2 = ball.y - worldClosestY2;
                    const distance2 = Math.sqrt(
                      distX2 * distX2 + distY2 * distY2
                    );

                    if (distance2 < ball.r) {
                      // ì—¬ì „íˆ ì•ˆìª½ì— ìˆìœ¼ë©´ ì¶”ê°€ë¡œ ë°€ì–´ë‚´ê¸°
                      const overlap2 = ball.r - distance2;
                      ball.x += (distX2 / distance2) * overlap2 * 2.0;
                      ball.y += (distY2 / distance2) * overlap2 * 2.0;
                    }

                    // 3ì°¨ ë³´ì •: ë§‰ëŒ€ê¸° ëë¶€ë¶„ì— ë‚‘í˜”ì„ ê²½ìš° ì²˜ë¦¬
                    const edgeDistance = Math.min(
                      Math.abs(localX - -pin.length / 2),
                      Math.abs(localX - pin.length / 2)
                    );
                    if (edgeDistance < ball.r * 0.5) {
                      // ë§‰ëŒ€ê¸° ëì— ê°€ê¹Œìš°ë©´ ìˆ˜ì§ ë°©í–¥ìœ¼ë¡œ ë°€ì–´ë‚´ê¸°
                      const edgeNormalX = localX < 0 ? -1 : 1;
                      const edgeNormalY = 0;
                      const worldEdgeNormalX =
                        edgeNormalX * cos - edgeNormalY * sin;
                      const worldEdgeNormalY =
                        edgeNormalX * sin + edgeNormalY * cos;
                      ball.x += worldEdgeNormalX * ball.r * 0.5;
                      ball.y += worldEdgeNormalY * ball.r * 0.5;
                    }
                  }

                  // ë§‰ëŒ€ê¸°ì˜ ë²•ì„  ë²¡í„°ë¥¼ ë”°ë¼ íŠ•ê¸°ê¸°
                  const normalX = Math.cos(pin.angle + Math.PI / 2);
                  const normalY = Math.sin(pin.angle + Math.PI / 2);
                  const dot = ball.vx * normalX + ball.vy * normalY;
                  ball.vx -= 2 * dot * normalX * 1.0; // íŠ•ê¹€ í˜ ì¤„ì„
                  ball.vy -= 2 * dot * normalY * 1.0;
                  ball.vx *= 0.85;
                  ball.vy *= 0.85;

                  // ë‚‘ê¹€ ë°©ì§€: ì†ë„ë„ ì¶”ê°€ë¡œ ë³´ì •
                  const finalDx = ball.x - pin.x;
                  const finalDy = ball.y - pin.y;
                  const finalLocalX = finalDx * cos - finalDy * sin;
                  const finalLocalY = finalDx * sin + finalDy * cos;
                  const finalDist = Math.sqrt(
                    Math.pow(
                      Math.max(
                        -pin.length / 2,
                        Math.min(finalLocalX, pin.length / 2)
                      ) - finalLocalX,
                      2
                    ) +
                      Math.pow(
                        Math.max(
                          -pin.width / 2,
                          Math.min(finalLocalY, pin.width / 2)
                        ) - finalLocalY,
                        2
                      )
                  );

                  if (finalDist < ball.r * 0.9) {
                    // ì—¬ì „íˆ ë„ˆë¬´ ê°€ê¹Œìš°ë©´ ì†ë„ë¡œ ë°€ì–´ë‚´ê¸°
                    const escapeSpeed = 2.0;
                    ball.vx +=
                      (finalDx /
                        Math.sqrt(finalDx * finalDx + finalDy * finalDy)) *
                      escapeSpeed;
                    ball.vy +=
                      (finalDy /
                        Math.sqrt(finalDx * finalDx + finalDy * finalDy)) *
                      escapeSpeed;
                  }

                  // ìœ„ë¡œ ë„ˆë¬´ íŠ•ê¸°ëŠ” ê²ƒ ë°©ì§€ (ì•„ë˜ ë°©í–¥ ì†ë„ ìš°ì„ )
                  if (ball.vy < 0) {
                    ball.vy = Math.max(ball.vy, -0.5); // ìœ„ë¡œ ìµœëŒ€ 0.5ê¹Œì§€ë§Œ (ë” ì œí•œ)
                  }
                  // í•­ìƒ ì•„ë˜ë¡œ ë–¨ì–´ì§€ë„ë¡ ë³´ì¥ (ê°•í™”)
                  if (ball.vy < 0.5) {
                    ball.vy = 0.5; // ìµœì†Œ ì•„ë˜ ë°©í–¥ ì†ë„ ë³´ì¥
                  }

                  playSound("bounce");
                  vibrate(10);
                }
              } else if (pin.type === "windmill") {
                // í’ì°¨ì™€ ê³µì˜ ìƒí˜¸ì‘ìš© (ëŒì–´ë‹¹ê¸°ê¸°, ì¡ê¸°, ë˜ì§€ê¸°)
                const dx = ball.x - pin.x;
                const dy = ball.y - pin.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // ì´ë¯¸ ê³µì„ ì¡ê³  ìˆìœ¼ë©´ ì²˜ë¦¬ ì•ˆ í•¨
                if (pin.catchBall === ball) {
                  return;
                }

                // ëŒì–´ë‹¹ê¸°ëŠ” ë²”ìœ„ ë‚´ì— ìˆìœ¼ë©´
                if (distance < pin.pullRadius && !pin.catchBall) {
                  // í’ì°¨ ìª½ìœ¼ë¡œ ëŒì–´ë‹¹ê¸°ê¸°
                  const pullForce =
                    ((pin.pullRadius - distance) / pin.pullRadius) * 2.0;
                  ball.vx += (dx / distance) * pullForce * 0.5;
                  ball.vy += (dy / distance) * pullForce * 0.5;
                  pin.particleEffect = 10; // ê¸€ë¡œìš° íš¨ê³¼
                }

                // ì§ì ‘ ì¶©ëŒ ì‹œ
                if (distance < ball.r + pin.radius && !pin.catchBall) {
                  // ê³µì„ ì¡ê¸° (50% í™•ë¥ )
                  if (
                    Math.random() > 0.5 &&
                    distance < ball.r + pin.radius * 0.8
                  ) {
                    pin.catchBall = ball;
                    pin.catchAngle = pin.angle;
                    pin.particleEffect = 30; // í° ê¸€ë¡œìš° íš¨ê³¼
                    playSound("finish");
                    vibrate(50);
                  } else {
                    // ì•„ë‹ˆë©´ íŠ•ê¸°ê¸°
                    const angle = Math.atan2(dy, dx);
                    const overlap = ball.r + pin.radius - distance;
                    ball.x += (dx / distance) * overlap * 1.1;
                    ball.y += (dy / distance) * overlap * 1.1;

                    const speed = Math.sqrt(
                      ball.vx * ball.vx + ball.vy * ball.vy
                    );
                    const bounceForce = Math.max(speed * 3.0, 5.0); // ë” ê°•í•˜ê²Œ

                    // í’ì°¨ íšŒì „ ë°©í–¥ì— ë”°ë¼ íŠ•ê¸°ê¸°
                    const rotationAngle = pin.angle + Math.PI / 2;
                    ball.vx = Math.cos(rotationAngle) * bounceForce;
                    ball.vy = Math.sin(rotationAngle) * bounceForce - 3; // ìœ„ë¡œ ì¶”ê°€ í˜

                    // ìœ„ë¡œ íŠ•ê¸°ëŠ” ê²ƒì„ í—ˆìš©
                    if (ball.vy < -6) {
                      ball.vy = -6;
                    }

                    playSound("bounce");
                    vibrate(15);
                  }
                }
              }
            }
          });

          // ìƒˆì™€ ì¶©ëŒ
          if (bird) {
            const dx = ball.x - bird.x;
            const dy = ball.y - bird.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const collisionDistance = ball.r + bird.size * 0.6; // ìƒˆì™€ ê³µì˜ ì¶©ëŒ ë²”ìœ„

            if (distance < collisionDistance && distance > 0) {
              // ì¶©ëŒ ì²˜ë¦¬
              const overlap = collisionDistance - distance;
              ball.x += (dx / distance) * overlap * 1.1;
              ball.y += (dy / distance) * overlap * 1.1;

              // ìœ„ë¡œ ê°•í•˜ê²Œ íŠ•ê¸°ê¸° (ìƒˆê°€ ê³µì„ ìœ„ë¡œ ë°€ì–´ì˜¬ë¦¼)
              const speed = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
              const bounceForce = Math.max(speed * 2.0, 3.5); // ìƒˆëŠ” ê°•í•˜ê²Œ íŠ•ê¹€

              // ìœ„ ë°©í–¥ìœ¼ë¡œ ê°•í•˜ê²Œ íŠ•ê¸°ê¸°
              const angle = Math.atan2(dy, dx);
              ball.vx = Math.cos(angle) * bounceForce * 0.6;
              ball.vy = Math.sin(angle) * bounceForce * 1.3; // ìœ„ë¡œ ê°•í•˜ê²Œ

              // ì¶”ê°€ ìœ„ ë°©í–¥ í˜
              ball.vy -= bounceForce * 0.7;

              // ìƒˆë„ ë°˜ëŒ€ ë°©í–¥ìœ¼ë¡œ ì‚´ì§ ë°€ë¦¼
              bird.vx -= (dx / distance) * 0.3;
              bird.vy -= (dy / distance) * 0.2;

              playSound("bounce");
              vibrate(20);
            }
          }

          // ê³µë¼ë¦¬ ì¶©ëŒ
          balls.forEach((other) => {
            if (ball === other || other.finished) return;

            const dx = ball.x - other.x;
            const dy = ball.y - other.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < ball.r + other.r && distance > 0) {
              const overlap = ball.r + other.r - distance;
              ball.x += (dx / distance) * overlap * 0.5;
              ball.y += (dy / distance) * overlap * 0.5;

              const angle = Math.atan2(dy, dx);
              const speed1 = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
              const speed2 = Math.sqrt(
                other.vx * other.vx + other.vy * other.vy
              );
              const bounceForce = (speed1 + speed2) * 0.2; // ê³µë¼ë¦¬ ì¶©ëŒ íŠ•ê¹€ ì¤„ì„

              ball.vx += Math.cos(angle) * bounceForce;
              ball.vy += Math.sin(angle) * bounceForce;

              // ìœ„ë¡œ ë„ˆë¬´ íŠ•ê¸°ëŠ” ê²ƒ ë°©ì§€
              if (ball.vy < 0) {
                ball.vy = Math.max(ball.vy, -0.3); // ìœ„ë¡œ ìµœëŒ€ 0.3ê¹Œì§€ë§Œ (ë” ì œí•œ)
              }
              // í•­ìƒ ì•„ë˜ë¡œ ë–¨ì–´ì§€ë„ë¡ ë³´ì¥
              if (ball.vy < 0.3) {
                ball.vy = 0.3; // ìµœì†Œ ì•„ë˜ ë°©í–¥ ì†ë„ ë³´ì¥
              }
            }
          });

          // ê²½ê³„ ì²´í¬
          if (ball.x < ball.r) {
            ball.x = ball.r;
            ball.vx *= -0.7;
          }
          if (ball.x > canvas.width - ball.r) {
            ball.x = canvas.width - ball.r;
            ball.vx *= -0.7;
          }

          // ê²°ìŠ¹ì„  í†µê³¼ (ì˜¤ëª©í•œ ê³¡ì„  ê¸°ì¤€)
          const finishBaseY = canvas.height - 50;
          const finishDepth = 40;
          const normalizedX = Math.max(0, Math.min(1, ball.x / canvas.width));
          const curve = 4 * normalizedX * (1 - normalizedX); // í¬ë¬¼ì„  ê³¡ì„ 
          const finishLineY = finishBaseY + finishDepth * curve;

          // ê³µì˜ ì¤‘ì‹¬ì´ ê³¡ì„ ì„ ë„˜ìœ¼ë©´ ì™„ì£¼
          if (ball.y >= finishLineY - ball.r && !ball.finished) {
            ball.finished = true;
            ball.finishOrder = finishedBalls.length + 1;
            finishedBalls.push(ball);
            playSound("finish");
            vibrate(50);

            // ì²« ë²ˆì§¸ ì™„ì£¼ì
            if (finishedBalls.length === 1) {
              playSound("finish");
              vibrate([100, 50, 100]);
            }
          }

          if (!ball.finished) drawBall(ball);
        });

        // ì™„ì£¼í•œ ê³µ í‘œì‹œ
        finishedBalls.forEach((ball) => {
          ctx.save();
          ctx.globalAlpha = 0.8;
          drawBall(ball);
          ctx.restore();

          // ìˆœìœ„ í‘œì‹œ (ë„¤ì˜¨ íš¨ê³¼)
          ctx.shadowBlur = 15;
          ctx.shadowColor = "#ffff00";
          ctx.fillStyle = "#ffff00";
          ctx.font = "bold 16px sans-serif";
          ctx.fillText(`${ball.finishOrder}ìœ„`, ball.x, ball.y - ball.r - 8);
          ctx.shadowBlur = 0;
        });

        ctx.restore(); // ì¹´ë©”ë¼ ë³€í™˜ ë³µì›

        // ì¹´ë©”ë¼ ì—…ë°ì´íŠ¸
        updateCamera();

        // íƒ€ì„ì•„ì›ƒ ì²´í¬ - ê²Œì„ì´ ë„ˆë¬´ ì˜¤ë˜ ì§€ì†ë˜ë©´ ê°•ì œ ì¢…ë£Œ
        const currentTime = Date.now();
        if (currentTime - gameStartTime > MAX_GAME_TIME) {
          // ë‚¨ì€ ê³µë“¤ì„ ëª¨ë‘ ì™„ì£¼ ì²˜ë¦¬ (í˜„ì¬ y ìœ„ì¹˜ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬)
          const remainingBalls = balls.filter((b) => !b.finished);
          remainingBalls.sort((a, b) => b.y - a.y); // ì•„ë˜ìª½ì— ìˆëŠ” ê³µì´ ë¨¼ì € ì™„ì£¼

          remainingBalls.forEach((ball) => {
            ball.finished = true;
            ball.finishOrder = finishedBalls.length + 1;
            finishedBalls.push(ball);
          });

          cancelAnimationFrame(animationId);
          showResult();
          return;
        }

        // ëª¨ë“  ê³µì´ ì™„ì£¼í–ˆëŠ”ì§€ ì²´í¬
        if (balls.every((b) => b.finished)) {
          cancelAnimationFrame(animationId);
          showResult();
          return;
        }

        animationId = requestAnimationFrame(animate);
      }

      /* ---------------- ê²°ê³¼ í‘œì‹œ ---------------- */
      function showResult() {
        resultEl.classList.remove("hidden");
        // ê²°ê³¼ ì˜ì—­ìœ¼ë¡œ ìŠ¤í¬ë¡¤
        setTimeout(() => {
          resultEl.scrollIntoView({ behavior: "smooth", block: "start" });
        }, 100);

        const sorted = [...finishedBalls].sort(
          (a, b) => a.finishOrder - b.finishOrder
        );

        const t = window.t || ((key, vars = {}) => key);
        resultEl.innerHTML = `
          <h2 class="text-2xl font-bold mb-4 text-center">${t("resultTitle")}</h2>
          <div class="space-y-2">
            ${sorted
              .map(
                (ball, i) => `
              <div class="flex items-center gap-3 p-3 rounded-lg ${
                i === 0
                  ? "bg-yellow-500/20 border-2 border-yellow-500"
                  : i < 3
                  ? "bg-slate-700"
                  : "bg-slate-700/50"
              }">
                <span class="text-2xl font-bold w-10 text-center">${
                  i + 1
                }</span>
                <div class="flex-1">
                  <div class="font-bold">${ball.name}</div>
                  <div class="text-xs text-slate-400">${ball.finishOrder}${t("resultFinishOrder")}</div>
                </div>
                ${
                  i === 0
                    ? '<span class="text-2xl">ğŸ†</span>'
                    : i === 1
                    ? '<span class="text-xl">ğŸ¥ˆ</span>'
                    : i === 2
                    ? '<span class="text-xl">ğŸ¥‰</span>'
                    : ""
                }
              </div>
            `
              )
              .join("")}
          </div>
          <button
            onclick="location.reload()"
            class="w-full mt-4 py-3 rounded-xl bg-emerald-400 text-black font-bold hover:bg-emerald-300 transition"
          >
            ${t("retryBtn")}
          </button>
        `;
      }

      /* ---------------- ê²Œì„ ì‹œì‘ ---------------- */
      document.getElementById("startBtn").onclick = () => {
        const t = window.t || ((key, vars = {}) => key);
        const input = participantsInput.value.trim();
        if (!input) {
          alert(t("alertNoInput"));
          return;
        }

        participants = parseParticipants(input);
        if (participants.length === 0) {
          alert(t("alertNoParticipants"));
          return;
        }

        canvasContainer.classList.remove("hidden");
        resultEl.classList.add("hidden");
        document
          .getElementById("startBtn")
          .parentElement.classList.add("hidden");

        initPins();
        initBalls();
        finishedBalls = [];
        cameraY = 0;
        gameStartTime = Date.now();
        animate();
      };

      /* ---------------- í˜ì´ì§€ ë¡œë“œ ì‹œ ê¸°ë³¸ê°’ ì„¤ì • ---------------- */
      window.addEventListener("DOMContentLoaded", () => {
        participantsInput.value = generateRandomNames(3);
      });
    </script>
  
<ins class="adsbygoogle"
     style="display:block; text-align:center"
     data-ad-format="fluid"
     data-ad-layout-key="-6t+ed+2i-1n-4w"
     data-ad-client="ca-pub-1204894220949193"
     data-ad-slot="7300458753"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
    
</body>
</html>
